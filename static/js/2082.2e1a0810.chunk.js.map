{"version":3,"file":"static/js/2082.2e1a0810.chunk.js","mappings":"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","sources":["hooks/useV2Pairs.ts","pages/LegacyPool/redirects.tsx"],"sourcesContent":["\"use strict\";\nimport { CurrencyAmount, V2_FACTORY_ADDRESSES } from \"@uniswap/sdk-core\";\nimport { Pair, computePairAddress } from \"@uniswap/v2-sdk\";\nimport { useMemo } from \"react\";\nimport { assume0xAddress } from \"utils/wagmi\";\nimport { useReadContracts } from \"wagmi\";\nexport var PairState = /* @__PURE__ */ ((PairState2) => {\n  PairState2[PairState2[\"LOADING\"] = 0] = \"LOADING\";\n  PairState2[PairState2[\"NOT_EXISTS\"] = 1] = \"NOT_EXISTS\";\n  PairState2[PairState2[\"EXISTS\"] = 2] = \"EXISTS\";\n  PairState2[PairState2[\"INVALID\"] = 3] = \"INVALID\";\n  return PairState2;\n})(PairState || {});\nexport function useV2Pairs(currencies) {\n  const chainId = currencies[0]?.[0]?.chainId;\n  const tokens = useMemo(\n    () => currencies.map(([currencyA, currencyB]) => [currencyA?.wrapped, currencyB?.wrapped]),\n    [currencies]\n  );\n  const pairAddresses = useMemo(\n    () => tokens.map(([tokenA, tokenB]) => {\n      return tokenA && tokenB && tokenA.chainId === tokenB.chainId && !tokenA.equals(tokenB) && V2_FACTORY_ADDRESSES[tokenA.chainId] ? computePairAddress({ factoryAddress: V2_FACTORY_ADDRESSES[tokenA.chainId], tokenA, tokenB }) : void 0;\n    }),\n    [tokens]\n  );\n  const { data, isLoading } = useReadContracts({\n    contracts: useMemo(() => {\n      return pairAddresses.map(\n        (pairAddress) => ({\n          address: assume0xAddress(pairAddress) ?? \"0x\",\n          // Edge case: if an address is undefined, we pass in a blank address to keep the result array the same length as pairAddresses\n          abi: [\n            {\n              constant: true,\n              inputs: [],\n              name: \"getReserves\",\n              outputs: [\n                {\n                  internalType: \"uint112\",\n                  name: \"reserve0\",\n                  type: \"uint112\"\n                },\n                {\n                  internalType: \"uint112\",\n                  name: \"reserve1\",\n                  type: \"uint112\"\n                },\n                {\n                  internalType: \"uint32\",\n                  name: \"blockTimestampLast\",\n                  type: \"uint32\"\n                }\n              ],\n              payable: false,\n              stateMutability: \"view\",\n              type: \"function\"\n            }\n          ],\n          functionName: \"getReserves\",\n          chainId\n        })\n      );\n    }, [pairAddresses, chainId])\n  });\n  return useMemo(() => {\n    if (isLoading) {\n      return Array.from({ length: pairAddresses.length }, () => [0 /* LOADING */, null]);\n    }\n    return data?.map(({ result }, i) => {\n      const tokenA = tokens[i][0];\n      const tokenB = tokens[i][1];\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) {\n        return [3 /* INVALID */, null];\n      }\n      if (!result) {\n        return [1 /* NOT_EXISTS */, null];\n      }\n      const [reserve0, reserve1] = result;\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n      return [\n        2 /* EXISTS */,\n        new Pair(\n          CurrencyAmount.fromRawAmount(token0, reserve0.toString()),\n          CurrencyAmount.fromRawAmount(token1, reserve1.toString())\n        )\n      ];\n    }) ?? [];\n  }, [data, isLoading, pairAddresses.length, tokens]);\n}\nexport function useV2Pair(tokenA, tokenB) {\n  const inputs = useMemo(() => [[tokenA, tokenB]], [tokenA, tokenB]);\n  return useV2Pairs(inputs)[0];\n}\n","\"use strict\";\nimport { ProtocolVersion } from \"@uniswap/client-pools/dist/pools/v1/types_pb\";\nimport { useCurrency } from \"hooks/Tokens\";\nimport { useV2Pair } from \"hooks/useV2Pairs\";\nimport { getCurrencyWithWrap } from \"pages/Pool/Positions/create/utils\";\nimport { Suspense, lazy } from \"react\";\nimport { Navigate, useParams, useSearchParams } from \"react-router-dom\";\nimport { parseCurrencyFromURLParameter } from \"state/swap/hooks\";\nimport { Loader } from \"ui/src/loading/Loader\";\nimport { useEnabledChains } from \"uniswap/src/features/chains/hooks/useEnabledChains\";\nimport { toGraphQLChain } from \"uniswap/src/features/chains/utils\";\nimport { getChainIdFromChainUrlParam, searchParamToBackendName } from \"utils/chainParams\";\nimport { useAccount } from \"wagmi\";\nconst PoolFinder = lazy(() => import(\"pages/PoolFinder\"));\nexport function LegacyPoolRedirects() {\n  return <Navigate to=\"/positions\" replace />;\n}\nexport function PoolFinderRedirects() {\n  return <Suspense fallback={<Loader.Box />}>\r\n      <PoolFinder />\r\n    </Suspense>;\n}\nexport function RemoveLiquidityV2WithTokenRedirects() {\n  const { chainId: connectedChainId } = useAccount();\n  const { defaultChainId } = useEnabledChains();\n  const { currencyIdA, currencyIdB } = useParams();\n  const [searchParams] = useSearchParams();\n  const chainParam = searchParams.get(\"chain\") ?? void 0;\n  const currencyAddressA = parseCurrencyFromURLParameter(currencyIdA ?? \"\");\n  const currencyAddressB = parseCurrencyFromURLParameter(currencyIdB ?? \"\");\n  const chainId = getChainIdFromChainUrlParam(chainParam) ?? connectedChainId ?? defaultChainId;\n  const [currencyA, currencyB] = [useCurrency(currencyAddressA, chainId), useCurrency(currencyAddressB, chainId)];\n  const [, pair] = useV2Pair(\n    getCurrencyWithWrap(currencyA, ProtocolVersion.V2),\n    getCurrencyWithWrap(currencyB, ProtocolVersion.V2)\n  );\n  if (pair) {\n    return <Navigate to={`/positions/v2/${toGraphQLChain(chainId).toLowerCase()}/${pair.liquidityToken.address}`} replace />;\n  }\n  return <Navigate to=\"/positions\" replace />;\n}\nexport function LegacyPositionPageRedirects() {\n  const { tokenId } = useParams();\n  const [searchParams] = useSearchParams();\n  const { chainId: connectedChainId } = useAccount();\n  const { defaultChainId } = useEnabledChains();\n  const chainName = searchParamToBackendName(searchParams.get(\"chain\"))?.toLowerCase() ?? toGraphQLChain(connectedChainId ?? defaultChainId).toLowerCase();\n  return <Navigate to={`/positions/v3/${chainName}/${tokenId}`} replace />;\n}\n"],"names":["PairState","PairState2","useV2Pairs","currencies","chainId","tokens","useMemo","map","currencyA","currencyB","wrapped","pairAddresses","tokenA","tokenB","equals","V2_FACTORY_ADDRESSES","computePairAddress","factoryAddress","data","isLoading","useReadContracts","contracts","pairAddress","address","assume0xAddress","abi","constant","inputs","name","outputs","internalType","type","payable","stateMutability","functionName","Array","from","length","result","i","reserve0","reserve1","token0","token1","sortsBefore","Pair","CurrencyAmount","fromRawAmount","toString","useV2Pair","PoolFinder","lazy","LegacyPoolRedirects","Navigate","to","replace","PoolFinderRedirects","Suspense","fallback","Loader","Box","RemoveLiquidityV2WithTokenRedirects","connectedChainId","useAccount","defaultChainId","useEnabledChains","currencyIdA","currencyIdB","useParams","searchParams","useSearchParams","chainParam","get","currencyAddressA","parseCurrencyFromURLParameter","currencyAddressB","getChainIdFromChainUrlParam","useCurrency","pair","getCurrencyWithWrap","ProtocolVersion","V2","toGraphQLChain","toLowerCase","liquidityToken","LegacyPositionPageRedirects","searchParamToBackendName","tokenId","chainName"],"sourceRoot":""}